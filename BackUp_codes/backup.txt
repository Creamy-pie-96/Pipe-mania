#include <iostream>
#include <limits>
#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <ctime>
#include <cstdlib>
#include <vector>
#include <chrono>
#include <thread>
#include <math.h>
#include <utility>
#include <algorithm> // Required for std::sort, std::min, std::max, std::clamp
#include <fstream>
#include <string>
#include <sstream>   // Required for stringstream
#include <iomanip>   // Required for setprecision

using namespace std; // Using namespace std for convenience in this single file

// --- Options Class (defined globally) ---
class Options
{
public:
    bool soundOn = true;
    bool isFullscreen = false;
    float volume = 100.f; // Initialize volume to a default value (0-100)
    unsigned int difficulty = 1; // 1 is easy 2 medium 3 hard
    bool resetScores = false; // Trigger flag
    float controlSensitivity = 1.0f; // Initialize sensitivity (e.g., 0.5 to 2.0 range)

    // Optional: Save and Load functions would go here later
};

// Global Options object
Options gameOptions;

// --- Enum Definitions (Moved to top) ---
enum class GameState
{
    Playing,
    GameOver
};

// --- Global Variables (Moved to top) ---
vector<pair<string, int>> HighScores;
bool highScoreProcessed = false;
bool atHomescreen = true; // Controls the main loop in main()

// Global game state (used in gameLoop)
GameState gameState = GameState::Playing;

// Global pipe variables (used in gameLoop)

// --- Function Declarations ---
void gameLoop(string Player);
void loadGame(); // Declared but not defined/used in this version
void homePage();
string name();

// Corrected function signature: showOptionsMenu must take Options&
void showOptionsMenu(Options& gameOptions);


// --- High Score Functions ---
void loadHighScores()
{
    ifstream file("UserData/score.txt");
    if (!file.is_open())
    {
        cerr << "Failed to open user data file (UserData/score.txt) for reading.\n";
        return;
    }
    string line;
    while (getline(file, line))
    {
        size_t spacePos = line.find(' ');
        if (spacePos != string::npos && spacePos > 0 && spacePos < line.length() - 1)
        {
            string username = line.substr(0, spacePos);
            string scoreStr = line.substr(spacePos + 1);
            try
            {
                int score = stoi(scoreStr);
                HighScores.push_back({username, score});
            }
            catch (const std::invalid_argument &ia)
            {
                cerr << "Warning: Invalid score format in line: '" << line << "' - " << ia.what() << '\n';
            }
            catch (const std::out_of_range &oor)
            {
                cerr << "Warning: Score out of range in line: '" << line << "' - " << oor.what() << '\n';
            }
        }
        else
        {
            cerr << "Warning: Skipping malformed line in score.txt: '" << line << "'\n";
        }
    }
    file.close();
    // Sort by score descending
    std::sort(HighScores.begin(), HighScores.end(), [](const pair<string, int> &a, const pair<string, int> &b)
              { return a.second > b.second; });
}

void saveHighScores()
{
    ofstream file("UserData/score.txt");
    if (!file.is_open())
    {
        cerr << "Failed to open user data file (UserData/score.txt) for writing!\n";
        return;
    }
    // Only save the top 10 or fewer if less than 10 exist
    int numScoresToSave = std::min(static_cast<int>(HighScores.size()), 10);
    for (int i = 0; i < numScoresToSave; ++i)
    {
        file << HighScores[i].first << " " << HighScores[i].second << "\n";
    }
    file.close();
}

// --- Utility Functions ---

// Function to scale a sprite to a target width while maintaining aspect ratio
void scaleSpriteToWidth(sf::Sprite& sprite, float targetWidth)
{
    if (sprite.getTexture() == nullptr) {
        cerr << "Error: Cannot scale sprite to width, no texture assigned!" << endl;
        return;
    }

    float originalWidth = static_cast<float>(sprite.getTexture()->getSize().x);

    if (originalWidth == 0) {
        cerr << "Error: Cannot scale sprite with zero original width!" << endl;
        return;
    }

    float scaleFactor = targetWidth / originalWidth;
    sprite.setScale(scaleFactor, scaleFactor);
}

// Function to scale a sprite to a target height while maintaining aspect ratio
void scaleSpriteToHeight(sf::Sprite& sprite, float targetHeight)
{
    if (sprite.getTexture() == nullptr) {
        cerr << "Error: Cannot scale sprite to height, no texture assigned!" << endl;
        return;
    }

    float originalHeight = static_cast<float>(sprite.getTexture()->getSize().y);

    if (originalHeight == 0) {
        cerr << "Error: Cannot scale sprite with zero original height!" << endl;
        return;
    }

    float scaleFactor = targetHeight / originalHeight;
    sprite.setScale(scaleFactor, scaleFactor);
}


// OBB Collision related (currently not fully used in Bird::isDead but kept for reference)
std::vector<sf::Vector2f> getTransformedPoints(const sf::Sprite &sprite)
{
    std::vector<sf::Vector2f> points(4);
    sf::Transform transform = sprite.getTransform();
    sf::FloatRect bounds = sprite.getLocalBounds();
    points[0] = transform.transformPoint(0.f, 0.f);
    points[1] = transform.transformPoint(bounds.width, 0.f);
    points[2] = transform.transformPoint(bounds.width, bounds.height);
    points[3] = transform.transformPoint(0.f, bounds.height);
    return points;
}

// OBB Collision related
std::vector<sf::Vector2f> getAxes(const std::vector<sf::Vector2f> &points)
{
    std::vector<sf::Vector2f> axes;
    for (int i = 0; i < 4; ++i)
    {
        sf::Vector2f edge = points[(i + 1) % 4] - points[i];
        sf::Vector2f normal(-edge.y, edge.x);
        float length = std::sqrt(normal.x * normal.x + normal.y * normal.y);
        if (length != 0)
        {
            normal /= length;
            axes.push_back(normal);
        }
    }
    // Add check for duplicate axes if necessary for robustness
    return axes;
}

// OBB Collision related
void projectOntoAxis(const std::vector<sf::Vector2f> &points, const sf::Vector2f &axis, float &min, float &max)
{
    min = max = points[0].x * axis.x + points[0].y * axis.y;
    for (int i = 1; i < 4; ++i)
    {
        float proj = points[i].x * axis.x + points[i].y * axis.y;
        if (proj < min)
            min = proj;
        if (proj > max)
            max = proj;
    }
}

// Function to draw the outline of a sprite's global bounds (useful for debugging collision)
void drawOBBOutline(sf::RenderWindow &window, const sf::Sprite &sprite, const sf::Color &color)
{
    std::vector<sf::Vector2f> points = getTransformedPoints(sprite);
    sf::VertexArray lines(sf::LinesStrip, 5);
    for (int i = 0; i < 4; ++i)
    {
        lines[i].position = points[i];
        lines[i].color = color;
    }
    lines[4].position = points[0];
    lines[4].color = color;
    window.draw(lines);
}

// Function to check collision between a circle and an Axis-Aligned Bounding Box (AABB)
bool checkCircleAABBIntersection(const sf::Vector2f &circleCenter, float circleRadius, const sf::FloatRect &aabb)
{
    // Find the closest point to the circle center that is inside the AABB
    float closestX = std::max(aabb.left, std::min(circleCenter.x, aabb.left + aabb.width));
    float closestY = std::max(aabb.top, std::min(circleCenter.y, aabb.top + aabb.height));

    // Calculate the distance between the circle center and the closest point
    float distanceX = circleCenter.x - closestX;
    float distanceY = circleCenter.y - closestY;
    float distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);

    // If the distance squared is less than or equal to the circle radius squared, there's a collision
    return distanceSquared <= (circleRadius * circleRadius);
}


// --- Game Elements Classes ---

class Obstacle
{
public:
    sf::Sprite sprite;
    Obstacle(float width, float height, float x, float y, const sf::Texture &pipeTexture, bool flipY = false)
    {
        sprite.setTexture(pipeTexture);
        // Scale the obstacle to the desired width and height
        float scaleX = width / pipeTexture.getSize().x;
        float scaleY = height / pipeTexture.getSize().y;

        if (flipY)
        {
            // For top pipes, flip the y-scale and set the origin to the bottom of the texture
            sprite.setScale(scaleX, -scaleY);
            sprite.setOrigin(0.f, static_cast<float>(pipeTexture.getSize().y));
        }
        else
        {
            sprite.setScale(scaleX, scaleY);
        }
        sprite.setPosition(x, y);
    }

    void move(float dx)
    {
        sprite.move(dx, 0.f);
    }

    sf::FloatRect getBounds() const
    {
        // Get the global bounds of the sprite (taking into account position, rotation, and scale)
        return sprite.getGlobalBounds();
    }

    void draw(sf::RenderWindow &window)
    {
        window.draw(sprite);
    }

    sf::Vector2f getPosition() const
    {
        return sprite.getPosition();
    }
};

class pipePair
{
public:
    Obstacle top;
    Obstacle bottom;
    bool passed; // Flag to track if the bird has passed this pipe pair

    // Constructor
    pipePair(const sf::Texture &pipeTexture, float x, float gapHeight, float windowHeight)
        // Initialize top pipe (scale to fit gap and remaining height)
        : top(Obstacle(100.f, windowHeight - gapHeight, x, 0.f, pipeTexture, true)), // Use a fixed width (e.g., 100.f)
        // Initialize bottom pipe (position after gap)
          bottom(Obstacle(100.f, windowHeight - gapHeight, x, gapHeight, pipeTexture)) // Use the same fixed width
    {
        passed = false; // Initialize passed flag
         // Adjust top pipe height and position so the bottom of the top pipe is at gapHeight
        float topPipeActualHeight = top.sprite.getGlobalBounds().height;
        top.sprite.setPosition(x, gapHeight - topPipeActualHeight);

         // Adjust bottom pipe height and position so the top of the bottom pipe is at gapHeight
        float bottomPipeActualHeight = bottom.sprite.getGlobalBounds().height;
         bottom.sprite.setPosition(x, gapHeight); // Bottom pipe starts right after the gap
         // If you want the bottom of the top pipe to be at a certain Y,
         // the top pipe's Y position needs to be adjusted based on its scaled height and origin.
         // The current Obstacle constructor handles this with flipY and origin.
         // We just need to set the Y position of the *bottom* pipe correctly.
         bottom.sprite.setPosition(x, gapHeight); // Bottom pipe starts right after the gap
    }

    // Move both pipes horizontally
    void move(float dx)
    {
        top.move(dx);
        bottom.move(dx);
    }

    // Draw both pipes
    void draw(sf::RenderWindow &window)
    {
        top.draw(window);
        bottom.draw(window);
    }

    // Check if the bird has passed this pipe pair based on its horizontal position
    bool isPassed(const sf::Vector2f &birdPosition)
    {
        if (!passed && birdPosition.x > top.getPosition().x + top.getBounds().width)
        {
            passed = true;
            return true;
        }
        return false;
    }
};

std::vector<pipePair> pipes;
float obstacleSpawnTimer = 0.f;
float obstacleSpawnInterval = 2.f; // How often new pipes spawn (seconds)
const float baseSpeed = 200.f;     // Base horizontal speed of pipes and background


class Bird
{
public:
    sf::Sprite sprite;
    sf::Vector2f velocity;
    int score = 0;
    sf::Texture birdTexture;
    sf::CircleShape BirdCircle; // Collision circle for the bird

    Bird(float width, float height)
    {
        if (!birdTexture.loadFromFile("Textures/bird.png"))
        {
            std::cerr << "Failed to load bird texture!" << std::endl;
        }
        sprite.setTexture(birdTexture);

        // Scale the bird sprite to the desired width and height
        scaleSpriteToWidth(sprite, width); // Use the scaling function
        // If you want to scale by height instead, use scaleSpriteToHeight(sprite, height);

        sprite.setOrigin(sprite.getLocalBounds().width / 2.f, sprite.getLocalBounds().height / 2.f); // Set origin to center for rotation
        sprite.setPosition(400.f, 100.f); // Initial position
        velocity = sf::Vector2f(0.f, 0.f);

        // Set the radius of the collision circle based on the scaled bird sprite size
        // A radius of half the smaller dimension (width or height) is a common starting point
        float circleRadius = std::min(sprite.getGlobalBounds().width, sprite.getGlobalBounds().height) / 2.5f; // Adjusted radius for better fit
        BirdCircle.setRadius(circleRadius);
        BirdCircle.setFillColor(sf::Color::Transparent); // Make the circle invisible
        BirdCircle.setOutlineColor(sf::Color::Red);     // Give it an outline for debugging
        BirdCircle.setOutlineThickness(1.f);
    }

    void applyGravity(float gravity, float dt)
    {
        velocity.y += gravity * dt;
        sprite.move(0.f, velocity.y * dt);
    }

    void jump(float force)
    {
        velocity.y = -force;
    }

    void setPosition(float x, float y)
    {
        sprite.setPosition(x, y);
    }

    sf::Vector2f getPosition() const
    {
        return sprite.getPosition();
    }

    void draw(sf::RenderWindow &window)
    {
        window.draw(sprite);
        // Optional: Draw the collision circle for debugging
        // window.draw(BirdCircle);
    }

    // Check for collisions with window bounds and pipes (using Circle-AABB)
    bool isDead(float windowHeight)
    {
        sf::FloatRect birdBounds = sprite.getGlobalBounds();
        // Check collision with top and bottom window bounds
        if (birdBounds.top <= 0 || birdBounds.top + birdBounds.height >= windowHeight)
            return true;

        // Get the center of the collision circle
        sf::Vector2f circleCenter = BirdCircle.getPosition() + sf::Vector2f(BirdCircle.getRadius(), BirdCircle.getRadius());
        float circleRadius = BirdCircle.getRadius();


        // Check collision with each pipe pair
        for (auto &pipe : pipes)
        {
            sf::FloatRect topPipeBounds = pipe.top.sprite.getGlobalBounds();
            sf::FloatRect bottomPipeBounds = pipe.bottom.sprite.getGlobalBounds();

            // Check intersection with top pipe AABB
            if (checkCircleAABBIntersection(circleCenter, circleRadius, topPipeBounds))
            {
                std::cout << "Bird Died due to collision with top pipe\n";
                return true;
            }
             // Check intersection with bottom pipe AABB
            if (checkCircleAABBIntersection(circleCenter, circleRadius, bottomPipeBounds))
            {
                 std::cout << "Bird Died due to collision with bottom pipe\n";
                 return true;
            }
        }
        return false; // Not dead yet!
    }

    // Update the bird's rotation based on its vertical velocity
    void updateRotation()
    {
        float maxAngle = 40.f;  // Maximum upward rotation
        float minAngle = -25.f; // Maximum downward rotation (note: SFML rotation is counter-clockwise)

        float angle;
        if (velocity.y < 0)
        {
            // If moving upwards, tilt upwards (negative angle)
            // You can add more complex mapping based on velocity magnitude if desired
            angle = minAngle; // Fixed upward tilt when jumping
        }
        else
        {
            // If moving downwards, tilt downwards (positive angle)
            // Map vertical velocity to rotation angle (clamped to maxAngle)
            angle = std::min(maxAngle, velocity.y * 0.2f); // Adjust 0.2f for sensitivity
        }
        sprite.setRotation(angle);
    }

    // Update the position of the collision circle to match the bird sprite's position
    void updateCirclePosition()
    {
        // Position the circle centered on the bird sprite's origin
         BirdCircle.setPosition(sprite.getPosition().x - BirdCircle.getRadius(), sprite.getPosition().y - BirdCircle.getRadius());
    }
};

// --- Main Function ---
int main()
{
    loadHighScores();

    // Main game loop that handles transitions between menus and game
    while (atHomescreen)
    {
        homePage(); // Show the home page
    }

    // If atHomescreen becomes false (e.g., Exit button clicked) the loop ends
    return 0; // Exit the program
}

// loadGame function declared but not defined/used in this version
void loadGame()
{
    // This function could be used later for loading game state if needed
}

// --- Home Page Function ---
void homePage()
{
    sf::RenderWindow Homewindow(sf::VideoMode(800, 600), "Pipe Mania Menu", sf::Style::Default);
    Homewindow.setVerticalSyncEnabled(true); // Limit frame rate to refresh rate

    // --- Audio ---
    sf::SoundBuffer hoverBuffer;
    sf::SoundBuffer clickBuffer;

    // Corrected sound loading error messages and added buffer checks before playing
    if (!hoverBuffer.loadFromFile("Audio/button.wav"))
    {
        cerr << "Failed to load hover sound!\n";
    }

    if (!clickBuffer.loadFromFile("Audio/click2.wav"))
    {
        cerr << "Failed to load click sound!\n";
    }

    sf::Sound clickSound;
    sf::Sound hoverSound; // Corrected variable name

    // Set sound buffers if loaded successfully
    if (clickBuffer.getDuration() != sf::Time::Zero)
        clickSound.setBuffer(clickBuffer);
    if (hoverBuffer.getDuration() != sf::Time::Zero)
        hoverSound.setBuffer(hoverBuffer);

    // --- Background ---
    sf::Texture backgroundTexture;
    sf::Sprite backgroundSprite;
    if (!backgroundTexture.loadFromFile("Textures/Home.png"))
    {
        cerr << "Failed to load background texture!" << endl;
        Homewindow.close(); // Close window if background fails to load (critical)
        return; // Return from the function
    }
    backgroundSprite.setTexture(backgroundTexture);

    // Scale background to window height using the new function
    scaleSpriteToHeight(backgroundSprite, static_cast<float>(Homewindow.getSize().y));
    backgroundSprite.setPosition(0.f, 0.f);

    // --- Button Textures ---
    sf::Texture startNormalTexture;
    sf::Texture startHoverTexture;
    sf::Texture optionsNormalTexture;
    sf::Texture optionsHoverTexture;
    sf::Texture leaderboardNormalTexture;
    sf::Texture leaderboardHoverTexture;
    sf::Texture exitNormalTexture;
    sf::Texture exitHoverTexture;

    // Load button textures - Corrected return statements and added checks
    if (!startNormalTexture.loadFromFile("Textures/startButton.PNG") ||
        !startHoverTexture.loadFromFile("Textures/startButton_Hover.PNG"))
    {
        cerr << "Failed to load Start button textures!" << endl;
        Homewindow.close(); return;
    }
    if (!optionsNormalTexture.loadFromFile("Textures/optionsButton.PNG") ||
        !optionsHoverTexture.loadFromFile("Textures/optionsButton_Hover.PNG"))
    {
        cerr << "Failed to load Options button textures!" << endl;
        Homewindow.close(); return;
    }
    if (!leaderboardNormalTexture.loadFromFile("Textures/LeaderBoardButton.PNG") ||
        !leaderboardHoverTexture.loadFromFile("Textures/LeaderBoardButton_Hover.PNG"))
    {
        cerr << "Failed to load Leaderboard button textures!" << endl;
        Homewindow.close(); return;
    }
    if (!exitNormalTexture.loadFromFile("Textures/exitButton.PNG") ||
        !exitHoverTexture.loadFromFile("Textures/exitButton_Hover.PNG"))
    {
        cerr << "Failed to load Exit button textures!" << endl;
        Homewindow.close(); return;
    }

    // --- Button Sprites ---
    sf::Sprite startButtonSprite(startNormalTexture);
    sf::Sprite optionsButtonSprite(optionsNormalTexture);
    sf::Sprite leaderboardButtonSprite(leaderboardNormalTexture);
    sf::Sprite exitButtonSprite(exitNormalTexture);

    // Scale buttons based on a target width using the new function
    float targetButtonWidth = Homewindow.getSize().x / 4.f; // Target width is 1/4 of window width (adjust as needed)
    // Add a maximum width limit if buttons get too wide on large windows
    targetButtonWidth = std::min(targetButtonWidth, 300.f); // Example max width

    scaleSpriteToWidth(startButtonSprite, targetButtonWidth);
    scaleSpriteToWidth(optionsButtonSprite, targetButtonWidth);
    scaleSpriteToWidth(leaderboardButtonSprite, targetButtonWidth);
    scaleSpriteToWidth(exitButtonSprite, targetButtonWidth);


    // --- Button Positioning ---
    float startX = Homewindow.getSize().x * 0.1f; // Position buttons 10% from the left
    float startY = Homewindow.getSize().y * 0.4f; // Start the first button at 40% of the window height

    startButtonSprite.setPosition(startX, startY);

    // Calculate vertical spacing between buttons
    float baseGap = 20.f; // Base gap in pixels
    float heightScaleFactor = Homewindow.getSize().y / 600.f; // Scale gap based on window height change from a reference (e.g., 600)
    float scaledGap = baseGap * heightScaleFactor;

    float optionsY = startButtonSprite.getGlobalBounds().top + startButtonSprite.getGlobalBounds().height + scaledGap;
    optionsButtonSprite.setPosition(startX, optionsY);

    float leaderboardY = optionsButtonSprite.getGlobalBounds().top + optionsButtonSprite.getGlobalBounds().height + scaledGap;
    leaderboardButtonSprite.setPosition(startX, leaderboardY);

    float exitY = leaderboardButtonSprite.getGlobalBounds().top + leaderboardButtonSprite.getGlobalBounds().height + scaledGap;
    exitButtonSprite.setPosition(startX, exitY);


    // --- State Variables for Hover and Exit Delay ---
    sf::Sprite *lastHoveredButton = nullptr; // Pointer to the button currently being hovered
    bool exitMenu = false; // Flag to signal that a button has been clicked to exit the menu
    sf::Clock exitClock;   // Clock to manage the exit delay
    const float exitDelay = 0.3f; // Delay in seconds (adjust as needed, e.g., 0.3s to 0.5s)

    // Array to track which button was clicked for transitioning after the delay
    bool trackButton[4] = {false, false, false, false}; // [Start, Options, Leaderboard, Exit]


    // --- Main Loop for Home Page Window ---
    while (Homewindow.isOpen())
    {
        sf::Event event;
        // Process events
        while (Homewindow.pollEvent(event))
        {
            // Handle window closure and Escape key
            if (event.type == sf::Event::Closed || (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape))
            {
                atHomescreen = false; // Signal to main loop to exit home screen
                Homewindow.close();   // Close the home window
            }

            // Handle window resize event - Corrected to use event.size
            if (event.type == sf::Event::Resized)
            {
                // Update the view to match the new window size
                Homewindow.setView(sf::View(sf::FloatRect(0, 0, static_cast<float>(event.size.width), static_cast<float>(event.size.height))));

                // Recalculate button scales and positions based on the new window size
                float newTargetButtonWidth = static_cast<float>(event.size.width) / 4.f; // Use event.size.width
                newTargetButtonWidth = std::min(newTargetButtonWidth, 300.f); // Apply max width limit

                scaleSpriteToWidth(startButtonSprite, newTargetButtonWidth);
                scaleSpriteToWidth(optionsButtonSprite, newTargetButtonWidth);
                scaleSpriteToWidth(leaderboardButtonSprite, newTargetButtonWidth);
                scaleSpriteToWidth(exitButtonSprite, newTargetButtonWidth);

                // Rescale background to new window height - Use event.size.height
                scaleSpriteToHeight(backgroundSprite, static_cast<float>(event.size.height));
                backgroundSprite.setPosition(0.f, 0.f); // Keep background at top-left

                // Recalculate button positions based on new scales and window size - Use event.size
                float newStartX = static_cast<float>(event.size.width) * 0.1f; // Use event.size.width
                float newStartY = static_cast<float>(event.size.height) * 0.4f; // Use event.size.height
                startButtonSprite.setPosition(newStartX, newStartY);

                float newHeightScaleFactor = static_cast<float>(event.size.height) / 600.f; // Use event.size.height
                float newScaledGap = baseGap * newHeightScaleFactor;

                optionsButtonSprite.setPosition(newStartX, startButtonSprite.getGlobalBounds().top + startButtonSprite.getGlobalBounds().height + newScaledGap);
                leaderboardButtonSprite.setPosition(newStartX, optionsButtonSprite.getGlobalBounds().top + optionsButtonSprite.getGlobalBounds().height + newScaledGap);
                exitButtonSprite.setPosition(newStartX, leaderboardButtonSprite.getGlobalBounds().top + leaderboardButtonSprite.getGlobalBounds().height + newScaledGap);

                // Removed drawing call from resize handler
            }

            // Handle mouse movement for hover effects - Using improved logic
            if (event.type == sf::Event::MouseMoved)
            {
                sf::Vector2f mousePos = Homewindow.mapPixelToCoords(sf::Vector2i(event.mouseMove.x, event.mouseMove.y));

                // Determine which button is currently being hovered
                sf::Sprite *currentHoveredButton = nullptr;
                if (startButtonSprite.getGlobalBounds().contains(mousePos)) currentHoveredButton = &startButtonSprite;
                else if (optionsButtonSprite.getGlobalBounds().contains(mousePos)) currentHoveredButton = &optionsButtonSprite;
                else if (leaderboardButtonSprite.getGlobalBounds().contains(mousePos)) currentHoveredButton = &leaderboardButtonSprite;
                else if (exitButtonSprite.getGlobalBounds().contains(mousePos)) currentHoveredButton = &exitButtonSprite;


                // If the hovered button has changed since the last frame
                if (currentHoveredButton != lastHoveredButton)
                {
                    // If a new button is being hovered (and it's not moving off a button)
                    if (currentHoveredButton != nullptr)
                    {
                        // Play hover sound if sound is on and buffer is loaded
                        if (gameOptions.soundOn && hoverSound.getBuffer() != nullptr)
                            hoverSound.play();
                    }

                    // Update button textures and scales based on hover state
                    // Reset the previously hovered button's texture and scale
                    if (lastHoveredButton != nullptr) {
                         if(lastHoveredButton == &startButtonSprite) lastHoveredButton->setTexture(startNormalTexture);
                         else if(lastHoveredButton == &optionsButtonSprite) lastHoveredButton->setTexture(optionsNormalTexture);
                         else if(lastHoveredButton == &leaderboardButtonSprite) lastHoveredButton->setTexture(leaderboardNormalTexture);
                         else if(lastHoveredButton == &exitButtonSprite) lastHoveredButton->setTexture(exitNormalTexture);

                         // Scale back to normal size - Recalculate base scale factor
                         float currentTargetWidth = static_cast<float>(Homewindow.getSize().x) / 4.f;
                         currentTargetWidth = std::min(currentTargetWidth, 300.f);
                         scaleSpriteToWidth(*lastHoveredButton, currentTargetWidth);
                    }

                    // Set the texture and scale for the newly hovered button
                    if (currentHoveredButton != nullptr)
                    {
                        if(currentHoveredButton == &startButtonSprite) currentHoveredButton->setTexture(startHoverTexture);
                        else if(currentHoveredButton == &optionsButtonSprite) currentHoveredButton->setTexture(optionsHoverTexture);
                        else if(currentHoveredButton == &leaderboardButtonSprite) currentHoveredButton->setTexture(leaderboardHoverTexture);
                        else if(currentHoveredButton == &exitButtonSprite) currentHoveredButton->setTexture(exitHoverTexture);

                         // Scale up slightly on hover
                        currentHoveredButton->setScale(currentHoveredButton->getScale().x * 1.125f, currentHoveredButton->getScale().y * 1.125f); // Scale up by 12.5%
                    }


                    // Update the last hovered button pointer
                    lastHoveredButton = currentHoveredButton;
                }
            }

            // Handle mouse button presses
            if (event.type == sf::Event::MouseButtonPressed)
            {
                if (event.mouseButton.button == sf::Mouse::Left)
                {
                    sf::Vector2f mousePos = Homewindow.mapPixelToCoords(sf::Vector2i(event.mouseButton.x, event.mouseButton.y));

                    // Check which button was clicked
                    if (startButtonSprite.getGlobalBounds().contains(mousePos))
                    {
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                        cout << "Start button clicked!" << endl;
                        exitMenu = true;      // Signal exit
                        trackButton[0] = true; // Track that Start was clicked
                        exitClock.restart();  // Start exit timer
                        // Don't close window immediately, wait for delay
                    }
                    else if (optionsButtonSprite.getGlobalBounds().contains(mousePos))
                    {
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                        cout << "Options button clicked!" << endl;
                        exitMenu = true;      // Signal exit
                        trackButton[1] = true; // Track that Options was clicked
                        exitClock.restart();  // Start exit timer
                    }
                    else if (leaderboardButtonSprite.getGlobalBounds().contains(mousePos))
                    {
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                        cout << "Leaderboard button clicked!" << endl;
                        exitMenu = true;      // Signal exit
                        trackButton[2] = true; // Track that Leaderboard was clicked
                        exitClock.restart();  // Start exit timer
                    }
                    else if (exitButtonSprite.getGlobalBounds().contains(mousePos))
                    {
                         if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                        cout << "Exit button clicked!" << endl;
                        exitMenu = true;      // Signal exit
                        trackButton[3] = true; // Track that Exit was clicked
                        exitClock.restart();  // Start exit timer
                    }
                }
            }
        } // End of event polling loop

        // --- Handle Delayed Exit (Check outside the event polling loop) ---
        if (exitMenu)
        {
            // Check if enough time has passed since a button triggered the exit
             // Corrected comparison for floating point time (use >=) and removed || delayed from while loop condition
            if (exitClock.getElapsedTime().asSeconds() >= exitDelay)
            {
                Homewindow.close(); // Close the home window

                // Transition to the next state based on which button was clicked
                if (trackButton[0]) // Start button
                {
                    string playerName = name(); // Get player name
                    if (!playerName.empty()) {
                         gameLoop(playerName); // Start the game
                    } else {
                         // Handle case where name input was cancelled or empty
                         // Maybe return to home screen or show a message
                         atHomescreen = true; // Stay on home screen
                         // Reset trackButton flags if not starting game
                         trackButton[0] = false;
                    }
                    // No return here, main loop will continue checking atHomescreen
                }
                else if (trackButton[1]) // Options button
                {
                    trackButton[1] = false; // Reset flag
                    showOptionsMenu(gameOptions); // Show options menu (Pass gameOptions by reference) - Corrected function call
                    atHomescreen = true; // Return to home screen after options
                }
                else if (trackButton[2]) // Leaderboard button
                {
                     trackButton[2] = false; // Reset flag
                    // TODO: Implement leaderboard display logic here
                    cout << "Leaderboard not implemented yet." << endl;
                    atHomescreen = true; // Return to home screen for now
                }
                else if (trackButton[3]) // Exit button
                {
                    // atHomescreen is already set to false in event handler
                    // Nothing more needed here, main loop will terminate
                }

                 // Reset exitMenu flag after handling the transition
                 exitMenu = false;
            }
        }


        // --- Drawing ---
        Homewindow.clear(); // Clear the window with the default clear color

        // Draw background
        Homewindow.draw(backgroundSprite);

        // Draw buttons
        Homewindow.draw(startButtonSprite);
        Homewindow.draw(optionsButtonSprite);
        Homewindow.draw(leaderboardButtonSprite);
        Homewindow.draw(exitButtonSprite);

        Homewindow.display(); // Display the drawn elements

    } // End of main window loop

    // Return from homePage function (window is closed)
    return;
}


// --- Name Input Function ---
string name()
{
    // Create a new window for name input
    sf::RenderWindow inputWindow(sf::VideoMode(400, 200), "Enter Your Name", sf::Style::Close);
    inputWindow.setVerticalSyncEnabled(true); // Limit frame rate

    // Load font
    sf::Font font;
    if (!font.loadFromFile("Text/arial.ttf"))
    {
        cerr << "Failed to load font for input!" << endl;
        return ""; // Return empty string on error
    }

    // Create text objects for prompt and input
    sf::Text promptText("Enter your name:", font, 20);
    promptText.setFillColor(sf::Color::White);
    promptText.setPosition(20.f, 40.f);

    sf::Text inputText("", font, 24);
    inputText.setFillColor(sf::Color::Yellow);
    inputText.setPosition(20.f, 80.f);

    std::string userName = ""; // String to store user input
    const size_t maxNameLength = 15; // Maximum allowed name length

    // Input window loop
    while (inputWindow.isOpen())
    {
        sf::Event event;
        while (inputWindow.pollEvent(event))
        {
            // Handle window closure
            if (event.type == sf::Event::Closed)
            {
                inputWindow.close();
            }

            // Handle text input (printable characters, backspace, enter)
            if (event.type == sf::Event::TextEntered)
            {
                unsigned int unicode = event.text.unicode;

                if (unicode == '\b') // Handle backspace key
                {
                    if (!userName.empty())
                    {
                        userName.pop_back();
                    }
                }
                else if (unicode == '\r' || unicode == '\n') // Handle Enter key
                {
                    inputWindow.close(); // Close window on Enter
                }
                else if (unicode >= 32 && unicode < 127) // Handle printable ASCII characters
                {
                    if (userName.size() < maxNameLength) // Check against max length
                    {
                        userName += static_cast<char>(unicode);
                    }
                }
                inputText.setString(userName); // Update the text displayed
            }

            // Handle key presses (specifically Enter as an alternative to TextEntered '\r')
            if (event.type == sf::Event::KeyPressed)
            {
                 if (event.key.code == sf::Keyboard::Enter)
                 {
                    inputWindow.close(); // Close window on Enter
                 }
            }
        }

        // Drawing
        inputWindow.clear(sf::Color::Black); // Clear with black background
        inputWindow.draw(promptText);      // Draw prompt text
        inputWindow.draw(inputText);       // Draw user input text
        inputWindow.display();             // Display drawn elements
    }

    return userName; // Return the collected user name
}


// --- Options Menu Function ---
// Corrected function signature to take Options&
void showOptionsMenu(Options& gameOptions)
{
    sf::RenderWindow optionsWindow(sf::VideoMode(800, 600), "Options", sf::Style::Close);
    optionsWindow.setVerticalSyncEnabled(true);

    // --- Audio ---
    sf::SoundBuffer hoverBuffer;
    sf::SoundBuffer clickBuffer;

    // Corrected error messages and added buffer checks before playing
    if (!hoverBuffer.loadFromFile("Audio/button.wav"))
    {
        cerr << "Failed to load hover sound!\n";
    }

    if (!clickBuffer.loadFromFile("Audio/click2.wav"))
    {
        cerr << "Failed to load click sound!\n";
    }

    sf::Sound clickSound;
    sf::Sound hoverSound; // Corrected variable name

    // Set sound buffers if loaded successfully
    if (clickBuffer.getDuration() != sf::Time::Zero)
        clickSound.setBuffer(clickBuffer);
    if (hoverBuffer.getDuration() != sf::Time::Zero)
        hoverSound.setBuffer(hoverBuffer);


    // --- Font ---
    sf::Font font;
    // IMPORTANT: Use a valid path to a .ttf font file relative to your executable
    if (!font.loadFromFile("Text/arial.ttf"))
    {
        cerr << "Failed to load font for options menu!" << endl;
        optionsWindow.close(); return; // Close window and return on font error
    }

    // --- Graphical Assets ---
    sf::Texture sliderBarTexture;
    sf::Texture sliderThumbTexture;

    // Load graphical control textures - Corrected return statements and added checks
    if (!sliderBarTexture.loadFromFile("Textures/slider_bar.png")) { cerr << "Failed to load slider bar texture!" << endl; optionsWindow.close(); return; }
    if (!sliderThumbTexture.loadFromFile("Textures/slider_thumb.png")) { cerr << "Failed to load slider thumb texture!" << endl; optionsWindow.close(); return; }

    // Back button textures - Corrected syntax (removed semicolons) and added checks
    sf::Texture normalBackButtonTexture;
    sf::Texture hoverBackButtonTexture;
    if(!normalBackButtonTexture.loadFromFile("Textures/backButton_normal.png")) // Removed semicolon
    {
        cerr<<"Failed to load normal back button texture!\n";
    }
    if(!hoverBackButtonTexture.loadFromFile("Textures/backButton_hover.png")) // Removed semicolon
    {
        cerr<<"Failed to load hover back button texture!\n";
    }


    // --- Option Labels (Text) ---
    sf::Text soundLabel("Sound:", font, 25);
    soundLabel.setFillColor(sf::Color::White);
    soundLabel.setPosition(50.f, 50.f);

    sf::Text fullscreenLabel("Fullscreen:", font, 25);
    fullscreenLabel.setFillColor(sf::Color::White);
    fullscreenLabel.setPosition(50.f, 100.f);

    sf::Text volumeLabel("Volume:", font, 25);
    volumeLabel.setFillColor(sf::Color::White);
    volumeLabel.setPosition(50.f, 400.f);

    sf::Text difficultyLabel("Difficulty:", font, 25);
    difficultyLabel.setFillColor(sf::Color::White);
    difficultyLabel.setPosition(50.f, 150.f);

    sf::Text resetScoresLabel("Reset High Score:", font, 25);
    resetScoresLabel.setFillColor(sf::Color::White);
    resetScoresLabel.setPosition(50.f, 200.f);

    sf::Text controlSensitivityLabel("Sensitivity:", font, 25);
    controlSensitivityLabel.setFillColor(sf::Color::White);
    controlSensitivityLabel.setPosition(50.f, 300.f);

    // --- Graphical Controls (Circles and Sprites) ---

    // Checkboxes (using Circles as per your code)
    sf::CircleShape soundCircle(18.f);
    // Vertically center with label
    soundCircle.setPosition(300.f, 50.f + (soundLabel.getGlobalBounds().height / 2.f) - soundCircle.getRadius());
    soundCircle.setOutlineThickness(1.f);
    soundCircle.setOutlineColor(sf::Color::White);

    sf::CircleShape fullscreenCircle(18.f);
    // Vertically center with label
    fullscreenCircle.setPosition(300.f, 100.f + (fullscreenLabel.getGlobalBounds().height / 2.f) - fullscreenCircle.getRadius());
    fullscreenCircle.setOutlineThickness(1.f);
    fullscreenCircle.setOutlineColor(sf::Color::White);

    // Sliders
    sf::Sprite volumeBarSprite(sliderBarTexture);
    sf::Sprite volumeThumbSprite(sliderThumbTexture);
    sf::Sprite sensitivityBarSprite(sliderBarTexture);
    sf::Sprite sensitivityThumbSprite(sliderThumbTexture);

    // Scale sliders (using your scaling factor, adjusted slightly for potential visual fit)
    volumeBarSprite.setScale(.5f, .5f);
    volumeThumbSprite.setScale(.5f, .5f);
    sensitivityBarSprite.setScale(.5f, .5f);
    sensitivityThumbSprite.setScale(.5f, .5f);

    // Position sliders next to labels - Corrected vertical centering
    volumeBarSprite.setPosition(300.f, 400.f + (volumeLabel.getGlobalBounds().height / 2.f) - (volumeBarSprite.getGlobalBounds().height / 2.f));
    sensitivityBarSprite.setPosition(300.f, 300.f + (controlSensitivityLabel.getGlobalBounds().height / 2.f) - (sensitivityBarSprite.getGlobalBounds().height / 2.f));


    // --- Difficulty Buttons (Simple Text Buttons) ---
    sf::Text difficultyEasyText("Easy", font, 25);
    sf::Text difficultyMediumText("Medium", font, 25);
    sf::Text difficultyHardText("Hard", font, 25);

    // Initial colors (will be updated in the loop based on gameOptions)
    difficultyEasyText.setFillColor(sf::Color::White);
    difficultyMediumText.setFillColor(sf::Color::White);
    difficultyHardText.setFillColor(sf::Color::White);

    // Position difficulty text buttons
    difficultyEasyText.setPosition(300.f, 150.f);
    difficultyMediumText.setPosition(380.f, 150.f); // Adjust spacing
    difficultyHardText.setPosition(500.f, 150.f); // Adjust spacing


    // --- Reset High Score Button (Simple Text Button) ---
    sf::Text resetScoresButtonText("Reset", font, 25);
    resetScoresButtonText.setFillColor(sf::Color::Red);
    resetScoresButtonText.setPosition(300.f, 200.f); // Adjust position


    // --- Back Button (Image Button) ---
    sf::Sprite backButtonSprite; // Corrected variable name from backkButton
    // Set texture only if successfully loaded
    if (normalBackButtonTexture.getSize().x > 0) { // Check if texture is valid
        backButtonSprite.setTexture(normalBackButtonTexture);
         // Scale the back button using the new function
        float targetBackWidth = optionsWindow.getSize().x / 5.f; // Example: 1/5th of window width
        targetBackWidth = std::min(targetBackWidth, 150.f); // Example max width
        scaleSpriteToWidth(backButtonSprite, targetBackWidth);

        // Position the back button (e.g., centered horizontally, near the bottom)
        backButtonSprite.setPosition(static_cast<float>(optionsWindow.getSize().x) / 2.f - backButtonSprite.getGlobalBounds().width / 2.f, 500.f); // Centered horizontally, fixed vertical
    }


    // --- Text for displaying slider values ---
    sf::Text volumeValueText("", font, 25);
    volumeValueText.setFillColor(sf::Color::Cyan);
     // Position to the right of the volume bar (adjust spacing +10.f)
    volumeValueText.setPosition(volumeBarSprite.getPosition().x + volumeBarSprite.getGlobalBounds().width + 10.f, 150.f);

    sf::Text controlSensitivityValueText("", font, 25);
    controlSensitivityValueText.setFillColor(sf::Color::Cyan);
    // Position to the right of the sensitivity bar (adjust spacing +10.f)
    controlSensitivityValueText.setPosition(sensitivityBarSprite.getPosition().x + sensitivityBarSprite.getGlobalBounds().width + 10.f, 300.f);


    // --- State Variables ---
    bool isDraggingVolume = false;
    bool isDraggingSensitivity = false;
    sf::Clock delayClock;      // Clock to manage the exit delay
    bool delayedExit = false; // Flag to signal delayed exit - Corrected name from delayed
    const float exitDelay = 0.3f; // Delay in seconds for exiting options menu

    // Pointers for tracking hovered elements for hover sound/effects
    sf::CircleShape* lastHoveredCircle = nullptr;
    sf::Text* lastHoveredTextButton = nullptr; // For difficulty and reset buttons
    sf::Sprite* lastHoveredSprite = nullptr; // For the back button

    // Removed unused lasbutton variable


    // --- Slider Configuration ---
    const float thumbMargin = 10.f; // Margin from the ends of the bar where the thumb cannot go

    // Calculate the usable range for the thumb on the bar (bar width - thumb width - 2 * margin)
    // Ensure textures are loaded before accessing dimensions
    float volumeBarMovableRange = 0.f;
    float sensitivityBarMovableRange = 0.f;
    if (volumeBarSprite.getTexture() != nullptr && volumeThumbSprite.getTexture() != nullptr) {
         volumeBarMovableRange = volumeBarSprite.getGlobalBounds().width - volumeThumbSprite.getGlobalBounds().width - 2 * thumbMargin;
    }
     if (sensitivityBarSprite.getTexture() != nullptr && sensitivityThumbSprite.getTexture() != nullptr) {
        sensitivityBarMovableRange = sensitivityBarSprite.getGlobalBounds().width - sensitivityThumbSprite.getGlobalBounds().width - 2 * thumbMargin;
     }


    // Define the range of sensitivity values
    float minSensitivity = 0.5f;
    float maxSensitivity = 2.0f;


    // --- Initialize Slider Thumb Positions based on current Option Values ---
    // This is important so the sliders reflect the current settings when the options menu opens.

    // For Volume (Map gameOptions.volume [0, 100] to thumb position within the movable range)
     if (volumeBarMovableRange > 0) { // Only calculate if movable range is valid
        float volumePercentage = std::clamp(gameOptions.volume, 0.f, 100.f) / 100.f; // Get percentage (0 to 1) of the clamped volume
        float volumeBarLeft = volumeBarSprite.getGlobalBounds().left;
        float volumeThumbTargetX = volumeBarLeft + thumbMargin + volumePercentage * volumeBarMovableRange;
        volumeThumbSprite.setPosition(volumeThumbTargetX, volumeBarSprite.getPosition().y + (volumeBarSprite.getGlobalBounds().height / 2.f) - (volumeThumbSprite.getGlobalBounds().height / 2.f));
     }


    // For Sensitivity (Map gameOptions.controlSensitivity [min, max] to thumb position)
     if (sensitivityBarMovableRange > 0) { // Only calculate if movable range is valid
        float clampedSensitivity = std::clamp(gameOptions.controlSensitivity, minSensitivity, maxSensitivity);
        float sensitivityPercentage = (clampedSensitivity - minSensitivity) / (maxSensitivity - minSensitivity); // Get percentage (0 to 1) within the sensitivity range
        float sensitivityBarLeft = sensitivityBarSprite.getGlobalBounds().left;
        float sensitivityThumbTargetX = sensitivityBarLeft + thumbMargin + sensitivityPercentage * sensitivityBarMovableRange;
        sensitivityThumbSprite.setPosition(sensitivityThumbTargetX, sensitivityBarSprite.getPosition().y + (sensitivityBarSprite.getGlobalBounds().height / 2.f) - (sensitivityThumbSprite.getGlobalBounds().height / 2.f));
     }


    // --- Main Loop for Options Window ---
    while (optionsWindow.isOpen())
    {
        sf::Event event;
        // Process events (only if not in delayed exit state) - Removed || delayed
        while (optionsWindow.pollEvent(event))
        {
            // Handle window closure and Escape key
            if (event.type == sf::Event::Closed || (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape))
            {
                optionsWindow.close();
            }

            // Handle window resize event - Corrected to use event.size and added more elements
             if (event.type == sf::Event::Resized)
            {
                // Update the view to match the new window size
                optionsWindow.setView(sf::View(sf::FloatRect(0, 0, static_cast<float>(event.size.width), static_cast<float>(event.size.height))));

                // Recalculate positions and scales for all elements
                // This is a simplified approach; proper layout management requires more advanced techniques.
                // For now, elements are repositioned based on hardcoded offsets and scaled widths/heights.

                // Recalculate positions for labels and fixed elements
                soundLabel.setPosition(static_cast<float>(event.size.width) * 0.05f, static_cast<float>(event.size.height) * 0.08f); // Example: 5% from left, 8% from top
                fullscreenLabel.setPosition(static_cast<float>(event.size.width) * 0.05f, static_cast<float>(event.size.height) * 0.18f);
                volumeLabel.setPosition(static_cast<float>(event.size.width) * 0.05f, static_cast<float>(event.size.height) * 0.28f);
                difficultyLabel.setPosition(static_cast<float>(event.size.width) * 0.05f, static_cast<float>(event.size.height) * 0.38f);
                resetScoresLabel.setPosition(static_cast<float>(event.size.width) * 0.05f, static_cast<float>(event.size.height) * 0.48f);
                controlSensitivityLabel.setPosition(static_cast<float>(event.size.width) * 0.05f, static_cast<float>(event.size.height) * 0.58f);


                // Recalculate positions for checkboxes (circles) - Vertically center with new label positions
                soundCircle.setPosition(static_cast<float>(event.size.width) * 0.3f, soundLabel.getGlobalBounds().top + (soundLabel.getGlobalBounds().height / 2.f) - soundCircle.getRadius());
                fullscreenCircle.setPosition(static_cast<float>(event.size.width) * 0.3f, fullscreenLabel.getGlobalBounds().top + (fullscreenLabel.getGlobalBounds().height / 2.f) - fullscreenCircle.getRadius());


                // Recalculate positions for sliders
                volumeBarSprite.setPosition(static_cast<float>(event.size.width) * 0.3f, volumeLabel.getGlobalBounds().top + (volumeLabel.getGlobalBounds().height / 2.f) - (volumeBarSprite.getGlobalBounds().height / 2.f));
                sensitivityBarSprite.setPosition(static_cast<float>(event.size.width) * 0.3f, controlSensitivityLabel.getGlobalBounds().top + (controlSensitivityLabel.getGlobalBounds().height / 2.f) - (sensitivityBarSprite.getGlobalBounds().height / 2.f));


                // Recalculate positions for difficulty text buttons
                difficultyEasyText.setPosition(static_cast<float>(event.size.width) * 0.3f, difficultyLabel.getGlobalBounds().top);
                difficultyMediumText.setPosition(static_cast<float>(event.size.width) * 0.4f, difficultyLabel.getGlobalBounds().top); // Adjust spacing
                difficultyHardText.setPosition(static_cast<float>(event.size.width) * 0.5f, difficultyLabel.getGlobalBounds().top); // Adjust spacing


                // Recalculate position for Reset Scores button
                resetScoresButtonText.setPosition(static_cast<float>(event.size.width) * 0.3f, resetScoresLabel.getGlobalBounds().top);


                // Recalculate positions for slider value texts
                 volumeValueText.setPosition(volumeBarSprite.getPosition().x + volumeBarSprite.getGlobalBounds().width + 10.f, volumeLabel.getGlobalBounds().top);
                 controlSensitivityValueText.setPosition(sensitivityBarSprite.getPosition().x + sensitivityBarSprite.getGlobalBounds().width + 10.f, controlSensitivityLabel.getGlobalBounds().top);


                 // Recalculate scale and position for back button
                 if (backButtonSprite.getTexture() != nullptr) {
                    float newTargetBackWidth = static_cast<float>(event.size.width) / 5.f;
                    newTargetBackWidth = std::min(newTargetBackWidth, 150.f);
                    scaleSpriteToWidth(backButtonSprite, newTargetBackWidth);
                    // Reposition back button after scaling (e.g., centered horizontally, near the bottom)
                    backButtonSprite.setPosition(static_cast<float>(event.size.width) / 2.f - backButtonSprite.getGlobalBounds().width / 2.f, static_cast<float>(event.size.height) * 0.85f); // Example: 85% from top
                 }


                 // Recalculate slider movable ranges and thumb positions based on new scales
                 if (volumeBarSprite.getTexture() != nullptr && volumeThumbSprite.getTexture() != nullptr) {
                     volumeBarMovableRange = volumeBarSprite.getGlobalBounds().width - volumeThumbSprite.getGlobalBounds().width - 2 * thumbMargin;
                      if (volumeBarMovableRange > 0) {
                         float volumePercentage = std::clamp(gameOptions.volume, 0.f, 100.f) / 100.f;
                         float volumeBarLeft = volumeBarSprite.getGlobalBounds().left;
                         float volumeThumbTargetX = volumeBarLeft + thumbMargin + volumePercentage * volumeBarMovableRange;
                         volumeThumbSprite.setPosition(volumeThumbTargetX, volumeThumbSprite.getPosition().y); // Keep vertical position relative to bar
                      }
                 }
                 if (sensitivityBarSprite.getTexture() != nullptr && sensitivityThumbSprite.getTexture() != nullptr) {
                     sensitivityBarMovableRange = sensitivityBarSprite.getGlobalBounds().width - sensitivityThumbSprite.getGlobalBounds().width - 2 * thumbMargin;
                     if (sensitivityBarMovableRange > 0) {
                         float clampedSensitivity = std::clamp(gameOptions.controlSensitivity, minSensitivity, maxSensitivity);
                         float sensitivityPercentage = (clampedSensitivity - minSensitivity) / (maxSensitivity - minSensitivity);
                         float sensitivityBarLeft = sensitivityBarSprite.getGlobalBounds().left;
                         float sensitivityThumbTargetX = sensitivityBarLeft + thumbMargin + sensitivityPercentage * sensitivityBarMovableRange;
                         sensitivityThumbSprite.setPosition(sensitivityThumbTargetX, sensitivityThumbSprite.getPosition().y); // Keep vertical position relative to bar
                     }
                 }
            }


            // --- Handle Mouse Button Pressed (only if not dragging or delayed exiting) ---
            if (event.type == sf::Event::MouseButtonPressed && !isDraggingVolume && !isDraggingSensitivity)
            {
                if (event.mouseButton.button == sf::Mouse::Left)
                {
                    sf::Vector2f mousePos = optionsWindow.mapPixelToCoords(sf::Vector2i(event.mouseButton.x, event.mouseButton.y));

                    // Check for clicks on Checkboxes (Circles)
                    if (soundCircle.getGlobalBounds().contains(mousePos))
                    {
                        gameOptions.soundOn = !gameOptions.soundOn;
                        cout << "sound on: " << gameOptions.soundOn << endl;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                    }
                    // Use else if for mutually exclusive clicks
                    else if (fullscreenCircle.getGlobalBounds().contains(mousePos))
                    {
                        gameOptions.isFullscreen = !gameOptions.isFullscreen;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                         // TODO: Implement actual fullscreen toggle here - might require recreating the window
                    }

                    // Check for clicks on Difficulty Buttons (Text)
                    else if (difficultyEasyText.getGlobalBounds().contains(mousePos))
                    {
                        gameOptions.difficulty = 1;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                    }
                    else if (difficultyMediumText.getGlobalBounds().contains(mousePos))
                    {
                        gameOptions.difficulty = 2;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                    }
                    else if (difficultyHardText.getGlobalBounds().contains(mousePos))
                    {
                        gameOptions.difficulty = 3;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                    }

                    // Check for click on Reset Scores Button (Text)
                    else if (resetScoresButtonText.getGlobalBounds().contains(mousePos))
                    {
                        gameOptions.resetScores = true; // Set the reset flag
                        cout << "Reset High Score requested!" << endl;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                        // Your main game logic will need to check this flag and reset scores
                        // After resetting, set gameOptions.resetScores = false;
                    }

                    // Check for click on Back button (Sprite) - Corrected variable name
                    else if (backButtonSprite.getGlobalBounds().contains(mousePos))
                    {
                        cout << "Back button clicked!" << endl;
                        if (gameOptions.soundOn && clickSound.getBuffer() != nullptr) clickSound.play();
                        delayedExit = true; // Signal delayed exit
                        delayClock.restart(); // Start the exit timer
                        // Don't close window immediately
                    }

                    // Check for click on Slider Thumbs to start dragging
                    // Use if, as multiple thumbs could potentially be clicked (though unlikely)
                    if (volumeThumbSprite.getGlobalBounds().contains(mousePos)) { isDraggingVolume = true; }
                    if (sensitivityThumbSprite.getGlobalBounds().contains(mousePos)) { isDraggingSensitivity = true; }
                }
            }

            // --- Handle Mouse Button Released ---
            if (event.type == sf::Event::MouseButtonReleased)
            {
                if (event.mouseButton.button == sf::Mouse::Left)
                {
                    isDraggingVolume = false; // Stop dragging volume thumb
                    isDraggingSensitivity = false; // Stop dragging sensitivity thumb
                }
            }

            // --- Handle Mouse Movement (only if not delayed exiting) ---
            if (event.type == sf::Event::MouseMoved)
            {
                sf::Vector2f mousePos = optionsWindow.mapPixelToCoords(sf::Vector2i(event.mouseMove.x, event.mouseMove.y));

                // --- Volume Slider Dragging ---
                if (isDraggingVolume)
                {
                    // Calculate target thumb x position based on mouse, centered on thumb
                    float newThumbX = mousePos.x - (volumeThumbSprite.getGlobalBounds().width / 2.f);

                    // Clamp the target thumb x position within the bar bounds, accounting for margins
                    float barLeft = volumeBarSprite.getGlobalBounds().left;
                    float thumbWidth = volumeThumbSprite.getGlobalBounds().width;
                    float clampedThumbX = std::clamp(newThumbX, barLeft + thumbMargin, barLeft + volumeBarSprite.getGlobalBounds().width - thumbMargin - thumbWidth);

                    // Set the thumb's position
                    volumeThumbSprite.setPosition(clampedThumbX, volumeThumbSprite.getPosition().y);

                    // Update Volume Setting based on thumb position
                    float thumbPositionAlongBar = clampedThumbX - (barLeft + thumbMargin); // Position from the start of the movable range
                    float percentage = 0.f;
                    if (volumeBarMovableRange > 0) { // Prevent division by zero
                         percentage = thumbPositionAlongBar / volumeBarMovableRange;       // Percentage along the movable range (0 to 1)
                    }

                    gameOptions.volume = percentage * 100.f; // Map percentage to 0-100 range
                    gameOptions.volume = std::clamp(gameOptions.volume, 0.f, 100.f); // Ensure value is within range
                }

                 // --- Sensitivity Slider Dragging ---
                 if (isDraggingSensitivity)
                 {
                    // Calculate target thumb x position based on mouse, centered on thumb
                    float newThumbX = mousePos.x - (sensitivityThumbSprite.getGlobalBounds().width / 2.f);

                    // Clamp the target thumb x position within the bar bounds, accounting for margins
                    float barLeft = sensitivityBarSprite.getGlobalBounds().left;
                    float thumbWidth = sensitivityThumbSprite.getGlobalBounds().width;
                    float clampedThumbX = std::clamp(newThumbX, barLeft + thumbMargin, barLeft + sensitivityBarSprite.getGlobalBounds().width - thumbMargin - thumbWidth);

                     // Set the thumb's position
                    sensitivityThumbSprite.setPosition(clampedThumbX, sensitivityThumbSprite.getPosition().y);

                    // Update Sensitivity Setting based on thumb position
                    float thumbPositionAlongBar = clampedThumbX - (barLeft + thumbMargin); // Position from the start of the movable range
                    float percentage = 0.f;
                     if (sensitivityBarMovableRange > 0) { // Prevent division by zero
                        percentage = thumbPositionAlongBar / sensitivityBarMovableRange;       // Percentage along the movable range (0 to 1)
                     }


                    // Map percentage (0 to 1) to the sensitivity range (minSensitivity to maxSensitivity)
                    gameOptions.controlSensitivity = minSensitivity + percentage * (maxSensitivity - minSensitivity);
                    gameOptions.controlSensitivity = std::clamp(gameOptions.controlSensitivity, minSensitivity, maxSensitivity); // Ensure value is within range
                 }

                // --- Hover Effects (for sound and visual feedback) ---
                // Check if the mouse is over any interactive element

                bool isHoveringInteractiveElement = false; // Flag to track if *any* element is hovered

                // Check circles
                sf::CircleShape* currentHoveredCircle = nullptr;
                if (soundCircle.getGlobalBounds().contains(mousePos)) { currentHoveredCircle = &soundCircle; isHoveringInteractiveElement = true; }
                else if (fullscreenCircle.getGlobalBounds().contains(mousePos)) { currentHoveredCircle = &fullscreenCircle; isHoveringInteractiveElement = true; }

                 // Check text buttons (difficulty and reset)
                sf::Text* currentHoveredTextButton = nullptr;
                if(difficultyEasyText.getGlobalBounds().contains(mousePos)) { currentHoveredTextButton = &difficultyEasyText; isHoveringInteractiveElement = true; }
                else if(difficultyMediumText.getGlobalBounds().contains(mousePos)) { currentHoveredTextButton = &difficultyMediumText; isHoveringInteractiveElement = true; }
                else if(difficultyHardText.getGlobalBounds().contains(mousePos)) { currentHoveredTextButton = &difficultyHardText; isHoveringInteractiveElement = true; }
                else if(resetScoresButtonText.getGlobalBounds().contains(mousePos)) { currentHoveredTextButton = &resetScoresButtonText; isHoveringInteractiveElement = true; }

                // Check back button sprite - Corrected variable name
                 sf::Sprite* currentHoveredSprite = nullptr;
                 if (backButtonSprite.getGlobalBounds().contains(mousePos)) { currentHoveredSprite = &backButtonSprite; isHoveringInteractiveElement = true; }


                // Play hover sound only when entering an interactive element's area
                // Check if the mouse was NOT hovering an element last frame, but IS hovering one this frame
                if (isHoveringInteractiveElement && lastHoveredCircle == nullptr && lastHoveredTextButton == nullptr && lastHoveredSprite == nullptr)
                {
                     if (gameOptions.soundOn && hoverSound.getBuffer() != nullptr)
                         hoverSound.play();
                }

                // Update last hovered pointers
                lastHoveredCircle = currentHoveredCircle;
                lastHoveredTextButton = currentHoveredTextButton;
                lastHoveredSprite = currentHoveredSprite;


                // --- Visual Hover Effects ---

                // Circles (Resizing and Outline) - Corrected positioning after resizing
                 if (soundCircle.getGlobalBounds().contains(mousePos))
                 {
                     soundCircle.setOutlineThickness(4.f);
                     soundCircle.setRadius(21.f); // Larger radius on hover
                     // Recalculate position after changing radius to keep it centered on the label's line
                      soundCircle.setPosition(300.f, soundLabel.getGlobalBounds().top + (soundLabel.getGlobalBounds().height / 2.f) - soundCircle.getRadius()); // Use label's new position
                 }
                 else
                 {
                     // Reset effects if not hovered
                     soundCircle.setOutlineThickness(1.f);
                     soundCircle.setRadius(18.f); // Normal radius
                      soundCircle.setPosition(300.f, soundLabel.getGlobalBounds().top + (soundLabel.getGlobalBounds().height / 2.f) - soundCircle.getRadius()); // Use label's new position
                 }

                 if (fullscreenCircle.getGlobalBounds().contains(mousePos))
                 {
                     fullscreenCircle.setOutlineThickness(4.f);
                     fullscreenCircle.setRadius(21.f); // Larger radius on hover
                     // Recalculate position after changing radius
                      fullscreenCircle.setPosition(300.f, fullscreenLabel.getGlobalBounds().top + (fullscreenLabel.getGlobalBounds().height / 2.f) - fullscreenCircle.getRadius()); // Use label's new position
                 }
                 else
                 {
                     // Reset effects if not hovered
                     fullscreenCircle.setOutlineThickness(1.f);
                     fullscreenCircle.setRadius(18.f); // Normal radius
                     fullscreenCircle.setPosition(300.f, fullscreenLabel.getGlobalBounds().top + (fullscreenLabel.getGlobalBounds().height / 2.f) - fullscreenCircle.getRadius()); // Use label's new position
                 }

                 // Text Buttons (Optional: Change color or underline on hover)
                 // Example: Change color to yellow on hover
                 // Also ensure selected difficulty is green
                 if(difficultyEasyText.getGlobalBounds().contains(mousePos)) difficultyEasyText.setFillColor(sf::Color::Yellow);
                 else if(gameOptions.difficulty != 1) difficultyEasyText.setFillColor(sf::Color::White); // Reset if not selected
                 else difficultyEasyText.setFillColor(sf::Color::Green); // Selected

                 if(difficultyMediumText.getGlobalBounds().contains(mousePos)) difficultyMediumText.setFillColor(sf::Color::Yellow);
                 else if(gameOptions.difficulty != 2) difficultyMediumText.setFillColor(sf::Color::White); // Reset if not selected
                 else difficultyMediumText.setFillColor(sf::Color::Green); // Selected

                 if(difficultyHardText.getGlobalBounds().contains(mousePos)) difficultyHardText.setFillColor(sf::Color::Yellow);
                 else if(gameOptions.difficulty != 3) difficultyHardText.setFillColor(sf::Color::White); // Reset if not selected
                 else difficultyHardText.setFillColor(sf::Color::Green); // Selected

                 if(resetScoresButtonText.getGlobalBounds().contains(mousePos)) resetScoresButtonText.setFillColor(sf::Color::Yellow);
                 else resetScoresButtonText.setFillColor(sf::Color::Red); // Reset to normal color


                // Back Button (Texture Swap) - Corrected logic and variable name
                if (backButtonSprite.getTexture() != nullptr && hoverBackButtonTexture.getSize().x > 0) // Check if textures were loaded
                {
                     if (backButtonSprite.getGlobalBounds().contains(mousePos))
                     {
                         backButtonSprite.setTexture(hoverBackButtonTexture);
                         backButtonSprite.getScale().x * 1.125f, backButtonSprite.getScale().y * 1.125f;
                     }
                     else
                     {
                         backButtonSprite.setTexture(normalBackButtonTexture);
                         
                         backButtonSprite.getScale().x / 1.125f, backButtonSprite.getScale().y / 1.125f;
                     }
                }
            } // End of MouseMoved event
        } // End of event polling loop

        // --- Handle Delayed Exit (Check OUTSIDE the event polling loop) ---
        if (delayedExit)
        {
            // Check if enough time has passed since the back button triggered the exit
             // Corrected comparison for floating point time (use >=) and removed || delayed from while loop condition
            if (delayClock.getElapsedTime().asSeconds() >= exitDelay)
            {
                optionsWindow.close(); // Close the options window
            }
        }


        // --- Update Visual Indicators (Before Drawing) ---
        // Circle fill color based on option state
        soundCircle.setFillColor(gameOptions.soundOn ? sf::Color::Green : sf::Color::Red);
        fullscreenCircle.setFillColor(gameOptions.isFullscreen ? sf::Color::Green : sf::Color::Red);

        // Volume value text
        volumeValueText.setString(to_string(static_cast<int>(round(gameOptions.volume))));
         // Reposition volume value text after bar might have moved on resize
        volumeValueText.setPosition(volumeBarSprite.getPosition().x + volumeBarSprite.getGlobalBounds().width + 10.f, volumeLabel.getGlobalBounds().top);


        // Difficulty button colors (Highlight the selected difficulty) - Handled mostly in hover now, but ensure correct base color
         // This is now mostly handled in the MouseMoved hover logic for visual feedback,
         // but the click logic sets the gameOptions.difficulty which is the source of truth.
         // The hover logic temporarily changes color; the drawing loop sets the base color.
         // Let's keep the base color setting here based on gameOptions.difficulty if not currently hovered.
        if (!difficultyEasyText.getGlobalBounds().contains(optionsWindow.mapPixelToCoords(sf::Mouse::getPosition(optionsWindow))))
             difficultyEasyText.setFillColor(gameOptions.difficulty == 1 ? sf::Color::Green : sf::Color::White);
        if (!difficultyMediumText.getGlobalBounds().contains(optionsWindow.mapPixelToCoords(sf::Mouse::getPosition(optionsWindow))))
             difficultyMediumText.setFillColor(gameOptions.difficulty == 2 ? sf::Color::Green : sf::Color::White);
        if (!difficultyHardText.getGlobalBounds().contains(optionsWindow.mapPixelToCoords(sf::Mouse::getPosition(optionsWindow))))
             difficultyHardText.setFillColor(gameOptions.difficulty == 3 ? sf::Color::Green : sf::Color::White);
        // Reset scores button color (Red base, Yellow on hover)
         if (!resetScoresButtonText.getGlobalBounds().contains(optionsWindow.mapPixelToCoords(sf::Mouse::getPosition(optionsWindow))))
            resetScoresButtonText.setFillColor(sf::Color::Red);


        // Sensitivity value text (formatted to 2 decimal places)
        stringstream ss;
        ss << fixed << std::setprecision(2) << gameOptions.controlSensitivity;
        controlSensitivityValueText.setString(ss.str());
         // Reposition sensitivity value text after bar might have moved on resize
        controlSensitivityValueText.setPosition(sensitivityBarSprite.getPosition().x + sensitivityBarSprite.getGlobalBounds().width + 10.f, controlSensitivityLabel.getGlobalBounds().top);


        // --- Drawing ---
        optionsWindow.clear(sf::Color(30, 30, 30)); // Darker background

        // Draw labels
        optionsWindow.draw(soundLabel);
        optionsWindow.draw(fullscreenLabel);
        optionsWindow.draw(volumeLabel);
        optionsWindow.draw(difficultyLabel);
        optionsWindow.draw(resetScoresLabel);
        optionsWindow.draw(controlSensitivityLabel);

        // Draw graphical controls (Circles and Sprites)
        optionsWindow.draw(soundCircle);
        optionsWindow.draw(fullscreenCircle);

        optionsWindow.draw(volumeBarSprite);
        optionsWindow.draw(volumeThumbSprite);
        optionsWindow.draw(sensitivityBarSprite);
        optionsWindow.draw(sensitivityThumbSprite);

        // Draw difficulty buttons (text)
        optionsWindow.draw(difficultyEasyText);
        optionsWindow.draw(difficultyMediumText);
        optionsWindow.draw(difficultyHardText);

        // Draw Reset button (text)
        optionsWindow.draw(resetScoresButtonText);

        // Draw Back button (sprite) - Corrected variable name
         // Only draw if the texture was loaded
        if (backButtonSprite.getTexture() != nullptr) {
            optionsWindow.draw(backButtonSprite);
        }


        // Draw value texts for sliders
        optionsWindow.draw(volumeValueText);
        optionsWindow.draw(controlSensitivityValueText);

        optionsWindow.display(); // Display the drawn elements

    } // End of options window loop
}


// --- Game Loop Function ---
void gameLoop(string Player) // Player name is passed as an argument
{
    // Sound loading
    sf::SoundBuffer jumpBuffer;
    if (!jumpBuffer.loadFromFile("Audio/jump.wav"))
        cerr << "Failed to load jump sound!\n"; // Corrected error message
    sf::Sound jumpSound;
     if (jumpBuffer.getDuration() != sf::Time::Zero) jumpSound.setBuffer(jumpBuffer); // Check if buffer loaded and set


    sf::SoundBuffer gameoverBuffer;
    if (!gameoverBuffer.loadFromFile("Audio/Gameover.wav")) // Corrected path based on common structure if needed
        cerr << "Failed to load gameover sound!\n"; // Corrected error message
    sf::Sound gameoverSound;
     if (gameoverBuffer.getDuration() != sf::Time::Zero) gameoverSound.setBuffer(gameoverBuffer); // Check if buffer loaded and set


    sf::SoundBuffer collisionBuffer;
    if (!collisionBuffer.loadFromFile("Audio/collision.wav"))
        cerr << "Failed to load collision sound!\n"; // Corrected error message
    sf::Sound collisionSound;
     if (collisionBuffer.getDuration() != sf::Time::Zero) collisionSound.setBuffer(collisionBuffer); // Check if buffer loaded and set


    // Font and score
    sf::Font font;
    if (!font.loadFromFile("Text/arial.ttf"))
        cerr << "Failed to load font!\n"; // Corrected error message
    sf::Text scoreText;
    scoreText.setFont(font);
    scoreText.setCharacterSize(30);
    scoreText.setFillColor(sf::Color::White);
    scoreText.setPosition(10.f, 10.f);

    // Load pipe texture
    sf::Texture pipeTexture;
    if (!pipeTexture.loadFromFile("Textures/pipe.png"))
        cerr << "Failed to load pipe texture!\n"; // Corrected error message


    // Declare background texture and sprites
    sf::Texture backgroundTexture;
    sf::Sprite backgroundSprite1;
    sf::Sprite backgroundSprite2;

    // Seed the random number generator
    srand(static_cast<unsigned>(time(0)));

    // Create the main game window
    sf::RenderWindow window(sf::VideoMode(1920, 1080), "Flappy Bird", sf::Style::Default);
    window.setVerticalSyncEnabled(true); // Limit frame rate

    // Load background texture and set up scrolling sprites
    if (!backgroundTexture.loadFromFile("Textures/Background1.png")) // Use the filename you prefer
    {
        cerr << "Failed to load background texture!" << endl;
        window.close(); // Close the window if background fails to load (critical)
        return; // Return from the function
    }

    backgroundSprite1.setTexture(backgroundTexture);
    backgroundSprite2.setTexture(backgroundTexture);

    // Scale background sprites to window height using the new function (maintain aspect ratio)
    scaleSpriteToHeight(backgroundSprite1, static_cast<float>(window.getSize().y));
    scaleSpriteToHeight(backgroundSprite2, static_cast<float>(window.getSize().y));

    // Position background sprites side-by-side initially
    backgroundSprite1.setPosition(0.f, 0.f);
    backgroundSprite2.setPosition(backgroundSprite1.getGlobalBounds().width, 0.f);


    // Create the Bird object
    Bird bird(70.f, 70.f); // Initial size (will be scaled in Bird constructor)
    // BirdCircle radius is set in the Bird constructor

    // Initial bird position
    sf::Vector2u windowSize = window.getSize(); // Use a variable for window size
    float offsetX = static_cast<float>(windowSize.x) * 0.15f; // Example: 15% from left
    float offsetY = static_cast<float>(windowSize.y) / 2.f;
    bird.setPosition(offsetX, offsetY);

    // Set initial position for the bird's collision circle
    bird.updateCirclePosition();

    // Clock for delta time calculation
    sf::Clock clock;

    // Game loop
    while (window.isOpen())
    {
        // Calculate delta time (time since last frame)
        float dt = clock.restart().asSeconds();

        sf::Event event;

        // Event polling loop
        while (window.pollEvent(event))
        {
            // Handle window closure and Escape key
            if (event.type == sf::Event::Closed ||
                (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape))
                window.close();

            // Handle window resize event - Corrected to use event.size
            else if (event.type == sf::Event::Resized)
            {
                // Update window size variable
                windowSize.x = event.size.width;
                windowSize.y = event.size.height;

                // Update the view to match the new window size - Corrected to use event.size
                window.setView(sf::View(sf::FloatRect(0, 0, static_cast<float>(event.size.width), static_cast<float>(event.size.height))));

                // Adjust bird position based on resize (maintain relative position or reset)
                // A simpler approach for resize: Reset to initial fixed position on resize
                bird.setPosition(offsetX, offsetY);

                // Update circle position after bird position changes
                bird.updateCirclePosition();

                // Rescale background on window resize (maintain aspect ratio by height) using the new function - Corrected to use event.size
                scaleSpriteToHeight(backgroundSprite1, static_cast<float>(event.size.height));
                scaleSpriteToHeight(backgroundSprite2, static_cast<float>(event.size.height));

                // Reposition backgrounds after resize to ensure they are side-by-side
                backgroundSprite1.setPosition(0.f, 0.f);
                backgroundSprite2.setPosition(backgroundSprite1.getGlobalBounds().width, 0.f);

                // TODO: Need to handle repositioning/rescaling of existing pipes on resize!
                // This is more complex and might require iterating through 'pipes' and adjusting them.
                // For now, existing pipes will likely be in the wrong position/scale after resize.
            }

            // Handle 'R' key press to restart the game when in Game Over state
            if (gameState == GameState::GameOver &&
                event.type == sf::Event::KeyPressed &&
                event.key.code == sf::Keyboard::R)
            {
                // Reset game state and elements for a new game
                bird.setPosition(offsetX, offsetY); // Reset bird position to initial
                bird.velocity = sf::Vector2f(0.f, 0.f); // Reset bird velocity
                bird.score = 0; // Reset score
                pipes.clear(); // Remove all existing pipes
                obstacleSpawnTimer = 0.f; // Reset spawn timer
                bird.sprite.setRotation(0.f); // Reset bird rotation
                gameState = GameState::Playing; // Change game state back to Playing

                // Update circle position on restart
                bird.updateCirclePosition();

                // Reset the high score processed flag for the new game
                highScoreProcessed = false;

                // Reset background positions on restart to ensure seamless scrolling starts correctly
                backgroundSprite1.setPosition(0.f, 0.f);
                backgroundSprite2.setPosition(backgroundSprite1.getGlobalBounds().width, 0.f);
            }

            // Handle Space key press for bird jump when in Playing state
            if (event.type == sf::Event::KeyPressed &&
                event.key.code == sf::Keyboard::Space &&
                gameState == GameState::Playing)
            {
                bird.jump(400.f); // Apply jump force (adjust value as needed)
                if (gameOptions.soundOn && jumpSound.getBuffer() != nullptr) jumpSound.play(); // Play jump sound if sound is on and buffer loaded
            }
        } // End of event polling loop


        // --- Game State Logic ---

        if (gameState == GameState::Playing)
        {
            // Update obstacle spawn timer
            obstacleSpawnTimer += dt;
            if (obstacleSpawnTimer >= obstacleSpawnInterval)
            {
                obstacleSpawnTimer = 0.f; // Reset timer

                // Calculate random gap height for the new pipe pair
                float gap = 200.f; // Height of the gap between top and bottom pipes (adjust as needed)

                // Total height available for the top and bottom pipes (window height minus the gap)
                float availableHeight = static_cast<float>(windowSize.y) - gap;

                float minPipeHeight = 50.f; // Minimum height for either top or bottom pipe segment

                // Ensure there's enough space for minimum pipe heights and the gap
                if (availableHeight > 2 * minPipeHeight) {
                     // Random height for the top pipe segment (ensuring minimum bottom pipe height)
                     float maxTopPipeHeight = availableHeight - minPipeHeight;
                     float topPipeHeight = minPipeHeight + rand() % static_cast<int>(maxTopPipeHeight - minPipeHeight + 1);

                     float bottomPipeHeight = availableHeight - topPipeHeight; // The rest goes to the bottom pipe

                    float PipeX = static_cast<float>(windowSize.x) + 100.f; // Spawn pipes just off the right edge

                    // Create and add the new pipe pair
                    // The pipePair constructor now handles the positioning based on gapHeight
                    pipes.emplace_back(pipeTexture, PipeX, topPipeHeight + gap, static_cast<float>(windowSize.y)); // Pass window height to pipePair constructor
                } else {
                     // Fallback if window is too small for min pipes and gap
                     cerr << "Warning: Window height too small for minimum pipe height and gap!\n";
                     // You might want to handle this case differently, e.g., don't spawn pipes
                }
            }

            window.clear(sf::Color::Black); // Clear the window with black background

            // ** Update and draw scrolling background **
            // The background speed is based on pipe speed for a parallax effect
            float speedMultiplier = 1.0f + static_cast<float>(bird.score) / 100.f; // Example speed increase based on score
            float pipeMovementSpeed = baseSpeed * speedMultiplier;
            float backgroundSpeed = pipeMovementSpeed * 0.5f; // Background moves at half the pipe speed

            backgroundSprite1.move(-backgroundSpeed * dt, 0.f);
            backgroundSprite2.move(-backgroundSpeed * dt, 0.f);

            // Reposition backgrounds if they go off-screen to the left to create a loop
            if (backgroundSprite1.getGlobalBounds().left + backgroundSprite1.getGlobalBounds().width < 0)
            {
                backgroundSprite1.setPosition(backgroundSprite2.getGlobalBounds().left + backgroundSprite2.getGlobalBounds().width, 0.f);
            }
            if (backgroundSprite2.getGlobalBounds().left + backgroundSprite2.getGlobalBounds().width < 0)
            {
                backgroundSprite2.setPosition(backgroundSprite1.getGlobalBounds().left + backgroundSprite1.getGlobalBounds().width, 0.f);
            }

            window.draw(backgroundSprite1);
            window.draw(backgroundSprite2);


            // Cleanup off-screen pipes (remove pipes that are completely off the left edge)
            while (!pipes.empty() &&
                   pipes[0].top.getBounds().left + pipes[0].top.getBounds().width < 0)
            {
                pipes.erase(pipes.begin());
            }

            // Move & draw pipes, and check for scoring
            for (auto it = pipes.begin(); it != pipes.end(); ) // Use iterator for safe erasing
            {
                float speedMultiplier = 1.0f + static_cast<float>(bird.score) / 100.f; // Consistent speed increase
                float pipeSpeed = baseSpeed * speedMultiplier;

                it->move(-pipeSpeed * dt); // Move the pipe pair

                it->draw(window); // Draw the pipe pair

                // Check if the bird has passed this pipe pair
                if (it->isPassed(bird.getPosition()))
                {
                    // Increment score if passed and sound is on
                    cout << "Score! :" << ++bird.score << endl;
                    // Optional: Play a scoring sound here
                }
                 ++it; // Move to the next pipe pair
            }


            // Update bird's position based on gravity and velocity
            bird.applyGravity(980.f, dt); // Apply gravity (adjust 980.f as needed)

            // Update bird's rotation based on its velocity
            bird.updateRotation();

            // Update the collision circle's position to follow the bird sprite
            bird.updateCirclePosition();

            // Check for collisions (with window bounds and pipes)
            if (bird.isDead(static_cast<float>(windowSize.y))) // Pass window height for boundary check
            {
                 if (gameOptions.soundOn && collisionSound.getBuffer() != nullptr) collisionSound.play(); // Play collision sound
                 // Give a small delay for collision sound before game over sound
                 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Requires <chrono> and <thread>
                 if (gameOptions.soundOn && gameoverSound.getBuffer() != nullptr) gameoverSound.play(); // Play game over sound

                gameState = GameState::GameOver; // Change game state to Game Over
            }

            // Update and draw the score text
            scoreText.setString("Score: " + to_string(bird.score));
            window.draw(scoreText);

            // Draw the bird sprite
            bird.draw(window);


            window.display(); // Display the drawn elements
        }
        else if (gameState == GameState::GameOver)
        {
            // Process high score update only once per game over state
            if (!highScoreProcessed)
            {
                // --- High Score Processing ---

                // 1. Get the player's score
                int currentScore = bird.score;
                // Use the player name passed to the gameLoop function
                string playerName = Player; // Now using the actual player name

                // 2. Add the new score to the HighScores vector
                HighScores.push_back({playerName, currentScore});

                // 3. Sort the HighScores vector in descending order by score
                std::sort(HighScores.begin(), HighScores.end(), [](const pair<string, int> &a, const pair<string, int> &b)
                          {
                              return a.second > b.second; // Sort by the 'second' element (score) descending
                          });

                // 4. Trim the HighScores vector to the desired top N size (e.g., top 10)
                int topN = 10; // Define how many high scores to keep
                if (HighScores.size() > topN)
                {
                    HighScores.resize(topN);
                }

                // 5. Save the updated HighScores vector to the file
                saveHighScores(); // Call the save function

                // Set flag to indicate high score is processed for this game over
                highScoreProcessed = true;

                // --- End High Score Processing ---
            }

            // --- Drawing Game Over Screen ---
            // Clear the window before drawing game over elements
            window.clear(sf::Color(50, 50, 50)); // Darker background for game over

            sf::Text gameOverText;
            gameOverText.setFont(font);
            gameOverText.setCharacterSize(50);
            gameOverText.setFillColor(sf::Color::Red);

            // Display the Game Over message and the player's score.
            gameOverText.setString("Game Over!\nYour Score: " + to_string(bird.score) + "\nPress R to restart."); // Include "Your" score

            // Check if the current score is in the top N after sorting and trimming (optional)
            bool isNewHighScore = false;
            // Check if the current score is greater than or equal to the lowest score in the top 10
            if (bird.score > 0 && HighScores.size() > 0 && bird.score >= HighScores.back().second) {
                 // Then check if this exact score and player name exists in the top 10
                 for (const auto &hs_entry : HighScores)
                 {
                     if (hs_entry.second == bird.score && hs_entry.first == Player) // Check for matching score and player name
                     {
                         isNewHighScore = true;
                         break;
                     }
                 }
            }


            if (isNewHighScore)
            {
                 // Find the rank if it's a new high score
                 int rank = -1;
                 for(size_t i = 0; i < HighScores.size(); ++i) {
                     if (HighScores[i].second == bird.score && HighScores[i].first == Player) {
                         rank = static_cast<int>(i) + 1;
                         break;
                     }
                 }

                 if (rank != -1) {
                     gameOverText.setString("Game Over!\nNEW HIGH SCORE! #" + to_string(rank) + "\nYour Score: " + to_string(bird.score) + "\nPress R to restart.");
                 } else {
                     // Fallback if rank wasn't found (shouldn't happen if isNewHighScore is true)
                     gameOverText.setString("Game Over!\nYour Score: " + to_string(bird.score) + "\nPress R to restart.");
                 }
            }


            // Center the game over text
            sf::FloatRect textBounds = gameOverText.getLocalBounds();
            gameOverText.setOrigin(textBounds.left + textBounds.width / 2.f, textBounds.top + textBounds.height / 2.f);
            gameOverText.setPosition(static_cast<float>(windowSize.x) / 2.f, static_cast<float>(windowSize.y) / 2.f);


            window.draw(gameOverText); // Draw the game over text
            window.display();          // Display the drawn elements
            // --- End Drawing Game Over Screen ---
        }
    } // End of game loop
}